const { Events, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
const { buttonHandlers, modalHandlers, selectMenuHandlers } = require('./handlers.js');
const reviewCommand = require('./review.js');
const { EMBED_COLOR } = require('./config.js');
const { handleCommand, handleListButtons } = require('./commands.js');
const { Komponenten, Kategorien, NutzerDaten, TicketArten, TicketStatus, TicketPanel } = require('./config');
const handlers = require('./handlers');
const ticketSystem = require('./tickets.js');
const { 
    flowState, 
    showPaymentMethodSelection,
    handleMasteryBrawlerModal,
    handleBulkTrophiesModal,
    handleRankedRankSelection,
    handleMasterySelection,
    handleP11ModalSubmit,
} = require('./src/modules/ticketFlow.js');
const { InteractionResponseFlags } = require('discord.js');
const {
  allButtonHandlers,
  paymentModalHandlers,
  reviewFeedbackButtonHandlers,
  reviewFeedbackModalHandlers,
  sendIbanPaymentInformation,
  copyIbanHandler,
  ibanPaymentCompletedHandler,
  handleIbanPaymentCompletedModal,
  confirmPaymentReceivedHandler,
  denyPaymentReceivedHandler,
  sendBoostAvailableEmbed
} = require('./paymentHandlers.js');

// Track processed interactions to prevent duplicate handling
const processedInteractions = new Set();

/**
 * Set up all Discord interaction handlers
 */
function setupInteractions(client) {
  // Handle slash commands
  client.on(Events.InteractionCreate, async interaction => {
    if (!interaction.isCommand()) return;

    // Skip if already processed
    if (processedInteractions.has(interaction.id)) {
      console.log(`[INTERACTION] Skipping already processed command interaction: ${interaction.id}`);
      return;
    }
    
    // Mark as processed
    processedInteractions.add(interaction.id);
    
    // Set a timeout to clean up the processed interaction ID after 10 seconds
    setTimeout(() => {
      processedInteractions.delete(interaction.id);
    }, 10000);

    const { commandName } = interaction;

    if (commandName === 'review') {
      try {
        // Get command arguments
        const user = interaction.options.getUser('user');
        const message = interaction.options.getString('message');
        
        if (!user || !message) {
          return interaction.reply({
            content: 'Missing required arguments: user and message',
            ephemeral: true
          });
        }
        
        // Call the review command handler
        await reviewCommand.execute({
          author: interaction.user,
          channel: interaction.channel,
          reply: (content) => interaction.reply({ content, ephemeral: true }),
          guild: interaction.guild
        }, [user.id, message]);
        
      } catch (error) {
        console.error('Error executing review command:', error);
        await interaction.reply({
          content: 'There was an error while executing this command!',
          ephemeral: true
        });
      }
    } else if (commandName === 'list') {
      try {
        // Process using the handler from commands.js
        await handleCommand(interaction);
      } catch (error) {
        console.error('Error executing list command:', error);
        await interaction.reply({
          content: 'There was an error while executing this command!',
          ephemeral: true
        });
      }
    }
  });

  // Handle button interactions - SINGLE UNIFIED HANDLER
  client.on(Events.InteractionCreate, async interaction => {
    if (!interaction.isButton()) return;

    // Skip if already processed
    if (processedInteractions.has(interaction.id)) {
      console.log(`[INTERACTION] Skipping already processed button interaction: ${interaction.id}`);
      return;
    }
    
    // Skip if the interaction is no longer repliable
    if (!interaction.isRepliable()) {
      console.log(`[INTERACTION] Skipping non-repliable interaction: ${interaction.id}, button: ${interaction.customId}`);
      return;
    }
    
    // Mark as processed
    processedInteractions.add(interaction.id);
    
    // Set a timeout to clean up the processed interaction ID after 10 seconds
    setTimeout(() => {
      processedInteractions.delete(interaction.id);
    }, 10000);
    
    console.log(`[INTERACTION] Button clicked: ${interaction.customId} by user ${interaction.user.id}`);

    try {
      const { customId } = interaction;
      
      // Find the correct handler based on button ID
      let handlerFound = false;
      
      // Handle review accept/deny buttons first (from review.js)
      if (customId.startsWith('review_accept_') || customId.startsWith('review_deny_')) {
        try {
          const { handleButton } = require('./review.js');
          await handleButton(interaction);
          handlerFound = true;
          return;
        } catch (error) {
          console.error(`[INTERACTION] Error handling review moderation button ${customId}:`, error);
          if (!interaction.replied && !interaction.deferred) {
            await interaction.reply({
              content: 'An error occurred while processing this review action.',
              ephemeral: true
            });
          }
          handlerFound = true;
          return;
        }
      }
      
      // Check specific cases first
      if (customId.startsWith('copy_address_')) {
        const address = customId.replace('copy_address_', '');
        await interaction.reply({
          content: `${address}`,
          ephemeral: true
        });
        handlerFound = true;
      } else if (customId === 'copy_email') {
        try {
          const { PAYMENT_METHODS } = require('./config.js');
          const paypalEmail = (PAYMENT_METHODS && PAYMENT_METHODS.PAYPAL && PAYMENT_METHODS.PAYPAL.email) 
            ? PAYMENT_METHODS.PAYPAL.email 
            : 'mathiasbenedetto@gmail.com';
          
          // Send just the plain email, no labels or formatting
          await interaction.reply({
            content: paypalEmail,
            ephemeral: true
          });
          console.log(`[COPY_PAYPAL_EMAIL] User ${interaction.user.id} requested PayPal email.`);
          handlerFound = true;
        } catch (error) {
          console.error(`[COPY_PAYPAL_EMAIL] Error handling copy PayPal email:`, error);
          handlerFound = true; // Mark as handled even if there was an error
        }
      } else if (customId.startsWith('copy_amount_')) {
        const amount = customId.replace('copy_amount_', '');
        await interaction.reply({
          content: `${amount}`,
          ephemeral: true
        });
        handlerFound = true;
      } else if (customId.startsWith('copy_btc_amount_')) {
        const amount = customId.replace('copy_btc_amount_', '');
        await interaction.reply({
          content: `${amount}`,
          ephemeral: true
        });
        handlerFound = true;
      } else if (customId.startsWith('copy_ltc_amount_')) {
        const amount = customId.replace('copy_ltc_amount_', '');
        await interaction.reply({
          content: `${amount}`,
          ephemeral: true
        });
        handlerFound = true;
      }
      // HANDLERS FOR DYNAMICALLY CREATED BUTTONS (e.g. ranked_Legendary_1)
      else if (customId.startsWith('ranked_') && !customId.startsWith('ticket_')) {
        await handleRankedRankSelection(interaction, customId.replace(/^ranked_/, ''));
        handlerFound = true;
      } else if (customId.startsWith('mastery_') && !customId.startsWith('ticket_')) {
        await handleMasterySelection(interaction, customId.replace(/^mastery_/, ''));
        handlerFound = true;
      }
      // Handle review and feedback buttons
      else if (customId.startsWith('review_button_') || customId.startsWith('feedback_button_')) {
        try {
          // Get the base ID (review_button or feedback_button)
          const baseId = customId.split('_').slice(0, 2).join('_');
          
          // Import the review/feedback handlers directly
          const { reviewFeedbackButtonHandlers } = require('./paymentHandlers.js');
          
          if (reviewFeedbackButtonHandlers && reviewFeedbackButtonHandlers[baseId]) {
            await reviewFeedbackButtonHandlers[baseId](interaction);
            handlerFound = true;
          } else {
            console.error(`[INTERACTION] Review/feedback handler not found for ${baseId}`);
            await interaction.reply({
              content: 'This button function is currently unavailable.',
              ephemeral: true
            });
            handlerFound = true;
          }
        } catch (error) {
          console.error(`[INTERACTION] Error handling review/feedback button ${customId}:`, error);
          if (!interaction.replied && !interaction.deferred) {
            await interaction.reply({
              content: 'An error occurred while processing your request.',
              ephemeral: true
            });
          }
          handlerFound = true;
        }
      }
      // Handle review star rating buttons
      else if (customId.startsWith('review_star_')) {
        try {
          // Import the review star handler directly
          const { reviewFeedbackButtonHandlers } = require('./paymentHandlers.js');
          
          if (reviewFeedbackButtonHandlers && reviewFeedbackButtonHandlers['review_star_1']) {
            await reviewFeedbackButtonHandlers['review_star_1'](interaction);
            handlerFound = true;
          } else {
            console.error(`[INTERACTION] Review star handler not found for ${customId}`);
            await interaction.reply({
              content: 'The rating function is currently unavailable.',
              ephemeral: true
            });
            handlerFound = true;
          }
        } catch (error) {
          console.error(`[INTERACTION] Error handling review star button ${customId}:`, error);
          if (!interaction.replied && !interaction.deferred) {
            await interaction.reply({
              content: 'An error occurred while processing your rating.',
              ephemeral: true
            });
          }
          handlerFound = true;
        }
      }
      // Handle review anonymous/username buttons
      else if (customId.startsWith('review_anonymous_') || customId.startsWith('review_username_')) {
        try {
          // Get the base ID (review_anonymous or review_username)
          const baseId = customId.split('_').slice(0, 2).join('_');
          
          // Import the review anonymous handler directly
          const { reviewFeedbackButtonHandlers } = require('./paymentHandlers.js');
          
          if (reviewFeedbackButtonHandlers && reviewFeedbackButtonHandlers[baseId]) {
            await reviewFeedbackButtonHandlers[baseId](interaction);
            handlerFound = true;
          } else {
            console.error(`[INTERACTION] Review anonymity handler not found for ${baseId}`);
            await interaction.reply({
              content: 'This function is currently unavailable.',
              ephemeral: true
            });
            handlerFound = true;
          }
        } catch (error) {
          console.error(`[INTERACTION] Error handling review anonymity button ${customId}:`, error);
          if (!interaction.replied && !interaction.deferred) {
            await interaction.reply({
              content: 'An error occurred while processing your selection.',
              ephemeral: true
            });
          }
          handlerFound = true;
        }
      }
      // Find the correct handler based on button ID
      else if (buttonHandlers && buttonHandlers[customId]) {
        try {
        await buttonHandlers[customId](interaction, client);
        handlerFound = true;
        } catch (handlerError) {
          console.error(`[INTERACTION] Error in button handler for ${customId}:`, handlerError);
          // Don't attempt to respond if the error is about the interaction
          if (!handlerError.message.includes('Unknown interaction') && 
              !handlerError.message.includes('already been acknowledged')) {
            try {
              if (!interaction.replied && !interaction.deferred) {
                await interaction.reply({ 
                  content: 'An error occurred with this action. Please try again later.', 
                  ephemeral: true 
                });
              }
            } catch (replyError) {
              console.error(`[INTERACTION] Failed to send error reply for ${customId}:`, replyError);
            }
          }
          handlerFound = true; // Mark as handled even if there was an error
        }
      } else {
        // Check for prefix matches (like 'payment_completed_' etc)
        if (buttonHandlers) {
          for (const key of Object.keys(buttonHandlers)) {
            if (key.endsWith('_') && customId.startsWith(key)) {
              try {
              await buttonHandlers[key](interaction, client);
              handlerFound = true;
              break;
              } catch (prefixHandlerError) {
                console.error(`[INTERACTION] Error in prefix button handler ${key} for ${customId}:`, prefixHandlerError);
                // Don't attempt to respond if the error is about the interaction
                if (!prefixHandlerError.message.includes('Unknown interaction') && 
                    !prefixHandlerError.message.includes('already been acknowledged')) {
                  try {
                    if (!interaction.replied && !interaction.deferred) {
                      await interaction.reply({ 
                        content: 'An error occurred with this action. Please try again later.', 
                        ephemeral: true 
                      });
                    }
                  } catch (replyError) {
                    console.error(`[INTERACTION] Failed to send error reply for ${customId}:`, replyError);
                  }
                }
                handlerFound = true; // Mark as handled even if there was an error
                break;
              }
            }
          }
        }
      }
      
      if (!handlerFound) {
        console.warn(`[INTERACTION] Unhandled button interaction: ${customId}`);
        if (!interaction.replied && !interaction.deferred) {
          await interaction.reply({ 
            content: 'This button does not have a handler.', 
            ephemeral: true 
          }).catch(error => {
            console.error(`[INTERACTION] Error replying to unhandled button: ${error}`);
          });
        }
      }
    } catch (error) {
      console.error(`[INTERACTION] Error handling button interaction:`, error);
      if (!interaction.replied && !interaction.deferred) {
        await interaction.reply({ 
          content: 'An error occurred while processing your request.', 
          ephemeral: true 
        }).catch(secondError => {
          console.error(`[INTERACTION] Failed to send error response: ${secondError}`);
        });
      }
    }
  });

  // Handle select menu interactions
  client.on(Events.InteractionCreate, async interaction => {
    if (!interaction.isStringSelectMenu()) return;
    
    // Skip if already processed
    if (processedInteractions.has(interaction.id)) {
      console.log(`[INTERACTION] Skipping already processed select menu interaction: ${interaction.id}`);
      return;
    }
    
    // Mark as processed
    processedInteractions.add(interaction.id);
    
    // Set a timeout to clean up the processed interaction ID after 10 seconds
    setTimeout(() => {
      processedInteractions.delete(interaction.id);
    }, 10000);
    
    console.log(`[INTERACTION] Select menu used: ${interaction.customId} by user ${interaction.user.id}, values: ${interaction.values.join(', ')}`);
    
    try {
      const { customId } = interaction;
      
      // Skip if the interaction is no longer repliable
      if (!interaction.isRepliable()) {
        console.log(`[INTERACTION] Skipping non-repliable interaction: ${interaction.id}, select menu: ${customId}`);
        return;
      }
      
      // Find the correct handler based on select ID
      let handlerFound = false;
      
      if (customId === 'payment_method_select') {
        try {
          console.log(`[PAYMENT_SELECT] Processing payment method selection for ${interaction.user.id}: ${interaction.values[0]}`);
          
          // Check if the interaction has already been replied to
          if (interaction.replied || interaction.deferred) {
            console.log(`[PAYMENT_SELECT] Interaction ${interaction.id} has already been replied to, using followUp`);
            handlerFound = true;
            return;
          }
          
          const { flowState } = require('./src/modules/ticketFlow');
          const userData = flowState.get(interaction.user.id);
          
          if (!userData) {
            console.error(`[PAYMENT_SELECT] No user data found for ${interaction.user.id}`);
            await interaction.reply({ 
              content: 'Session data not found. Please try again.',
              ephemeral: true
            });
            handlerFound = true;
            return;
          }
          
          // Update payment method in user data
          const selectedMethod = interaction.values[0];
          
          // Map payment method values to display names
          const methodDisplayNames = {
            'paypal': 'PayPal',
            'crypto': 'Crypto',
            'iban': 'IBAN Bank Transfer',
            'paypal_giftcard': 'PayPal Giftcard',
            'dutch': 'Dutch Payment Methods',
            'apple_giftcard': 'German Apple Giftcard'
          };
          
          // Store both the raw value and the display name
          userData.paymentMethodRaw = selectedMethod;
          userData.paymentMethod = methodDisplayNames[selectedMethod] || selectedMethod;
          
          console.log(`[PAYMENT_SELECT] Set payment method for ${interaction.user.id} to: ${userData.paymentMethod} (${selectedMethod})`);
          
          // Update user data in the flow state
          flowState.set(interaction.user.id, userData);
          
          // Show price confirmation
          const { showPriceEmbed } = require('./src/modules/ticketFlow');
          await showPriceEmbed(interaction);
          
          handlerFound = true;
        } catch (error) {
          console.error(`[PAYMENT_SELECT] Error handling payment method selection:`, error);
          if (!interaction.replied && !interaction.deferred) {
            await interaction.reply({ 
              content: 'An error occurred while processing your payment method selection.', 
              ephemeral: true 
            });
          }
          handlerFound = true;
        }
      }
      // Handle other select menus
      else if (selectMenuHandlers && selectMenuHandlers[customId]) {
        try {
          await selectMenuHandlers[customId](interaction);
          handlerFound = true;
        } catch (error) {
          console.error(`[INTERACTION] Error in select menu handler for ${customId}:`, error);
          if (!interaction.replied && !interaction.deferred) {
            await interaction.reply({ 
              content: 'An error occurred while processing your selection.', 
              ephemeral: true 
            });
          }
          handlerFound = true;
        }
      }
      
      if (!handlerFound) {
        console.warn(`[INTERACTION] Unhandled select menu interaction: ${customId}`);
        if (!interaction.replied && !interaction.deferred) {
          await interaction.reply({ 
            content: 'This selection menu does not have a handler.', 
            ephemeral: true 
          });
        }
      }
    } catch (error) {
      console.error(`[INTERACTION] Error handling select menu interaction:`, error);
      if (!interaction.replied && !interaction.deferred) {
        await interaction.reply({ 
          content: 'An error occurred while processing your selection.', 
          ephemeral: true 
        }).catch(secondError => {
          console.error(`[INTERACTION] Failed to send error response: ${secondError}`);
        });
      }
    }
  });

  // Handle modal submissions
  client.on(Events.InteractionCreate, async interaction => {
    if (!interaction.isModalSubmit()) return;
    
    // Skip if already processed
    if (processedInteractions.has(interaction.id)) {
      console.log(`[INTERACTION] Skipping already processed modal interaction: ${interaction.id}`);
      return;
    }
    
    // Mark as processed
    processedInteractions.add(interaction.id);
    
    // Set a timeout to clean up the processed interaction ID after 10 seconds
    setTimeout(() => {
      processedInteractions.delete(interaction.id);
    }, 10000);
    
    try {
      const { customId } = interaction;
      console.log(`[INTERACTION] Modal submitted: ${customId} by user ${interaction.user.id}`);
      
      // Skip if the interaction is no longer repliable
      if (!interaction.isRepliable()) {
        console.log(`[INTERACTION] Skipping non-repliable interaction: ${interaction.id}, modal: ${customId}`);
        return;
      }
      
      let handlerFound = false;
      
      // Handle P11 modal submission
      if (customId === 'modal_p11_count') {
        try {
          console.log(`[INTERACTION] Handling P11 modal submission from ${interaction.user.id}`);
          await handleP11ModalSubmit(interaction);
          handlerFound = true;
        } catch (error) {
          console.error(`[INTERACTION] Error handling P11 modal submission:`, error);
          if (!interaction.replied && !interaction.deferred) {
            await interaction.reply({ 
              content: 'An error occurred while processing your P11 count. Please try again.', 
              ephemeral: true 
            });
          }
          handlerFound = true;
        }
      }
      // Handle mastery brawler modal submission
      else if (customId === 'modal_mastery_brawler') {
        try {
          await handleMasteryBrawlerModal(interaction);
          handlerFound = true;
        } catch (error) {
          console.error(`[INTERACTION] Error handling mastery brawler modal:`, error);
          if (!interaction.replied && !interaction.deferred) {
            await interaction.reply({ 
              content: 'An error occurred while processing your brawler information. Please try again.', 
              ephemeral: true 
            });
          }
          handlerFound = true;
        }
      }
      // Handle bulk trophies modal submission
      else if (customId === 'modal_trophies_start') {
        try {
          await handleBulkTrophiesModal(interaction);
          handlerFound = true;
        } catch (error) {
          console.error(`[INTERACTION] Error handling bulk trophies modal:`, error);
          if (!interaction.replied && !interaction.deferred) {
            await interaction.reply({ 
              content: 'An error occurred while processing your trophy information. Please try again.', 
              ephemeral: true 
            });
          }
          handlerFound = true;
        }
      }
      // Handle IBAN payment completed modal
      else if (customId === 'modal_iban_payment_completed') {
        try {
          await handleIbanPaymentCompletedModal(interaction);
          handlerFound = true;
        } catch (error) {
          console.error(`[INTERACTION] Error handling IBAN payment completed modal:`, error);
          if (!interaction.replied && !interaction.deferred) {
            await interaction.reply({ 
              content: 'An error occurred while processing your payment information. Please try again.', 
              ephemeral: true 
            });
          }
          handlerFound = true;
        }
      }
      // Handle other modals from modalHandlers
      else if (modalHandlers && modalHandlers[customId]) {
        try {
          await modalHandlers[customId](interaction);
          handlerFound = true;
        } catch (error) {
          console.error(`[INTERACTION] Error in modal handler for ${customId}:`, error);
          if (!interaction.replied && !interaction.deferred) {
            await interaction.reply({ 
              content: 'An error occurred while processing your submission. Please try again.', 
              ephemeral: true 
            });
          }
          handlerFound = true;
        }
      }
      // Handle review/feedback modals
      else if (customId.startsWith('modal_review_') || customId.startsWith('modal_feedback_')) {
        try {
          // Get the base modal ID
          const baseModalId = customId.split('_').slice(0, 3).join('_');
          
          if (reviewFeedbackModalHandlers && reviewFeedbackModalHandlers[baseModalId]) {
            await reviewFeedbackModalHandlers[baseModalId](interaction);
            handlerFound = true;
          } else {
            console.error(`[INTERACTION] Review/feedback modal handler not found for ${baseModalId}`);
            await interaction.reply({ 
              content: 'This form submission cannot be processed at this time.', 
              ephemeral: true 
            });
            handlerFound = true;
          }
        } catch (error) {
          console.error(`[INTERACTION] Error handling review/feedback modal ${customId}:`, error);
          if (!interaction.replied && !interaction.deferred) {
            await interaction.reply({ 
              content: 'An error occurred while processing your submission. Please try again.', 
              ephemeral: true 
            });
          }
          handlerFound = true;
        }
      }
      // Handle payment modals
      else if (customId.startsWith('modal_payment_')) {
        try {
          // Get the base modal ID
          const baseModalId = customId.split('_').slice(0, 3).join('_');
          
          if (paymentModalHandlers && paymentModalHandlers[baseModalId]) {
            await paymentModalHandlers[baseModalId](interaction);
            handlerFound = true;
          } else {
            console.error(`[INTERACTION] Payment modal handler not found for ${baseModalId}`);
            await interaction.reply({ 
              content: 'This payment form submission cannot be processed at this time.', 
              ephemeral: true 
            });
            handlerFound = true;
          }
        } catch (error) {
          console.error(`[INTERACTION] Error handling payment modal ${customId}:`, error);
          if (!interaction.replied && !interaction.deferred) {
            await interaction.reply({ 
              content: 'An error occurred while processing your payment information. Please try again.', 
              ephemeral: true 
            });
          }
          handlerFound = true;
        }
      }
      
      if (!handlerFound) {
        console.warn(`[INTERACTION] Unhandled modal interaction: ${customId}`);
        if (!interaction.replied && !interaction.deferred) {
          await interaction.reply({ 
            content: 'This form submission type is not currently supported.', 
            ephemeral: true 
          });
        }
      }
    } catch (error) {
      console.error(`[INTERACTION] Error handling modal submission:`, error);
      if (!interaction.replied && !interaction.deferred) {
        await interaction.reply({ 
          content: 'An error occurred while processing your form submission.', 
          ephemeral: true 
        }).catch(secondError => {
          console.error(`[INTERACTION] Failed to send error response: ${secondError}`);
        });
      }
    }
  });

  console.log("Interaction handlers have been set up");
}

module.exports = { setupInteractions }; 